// *********************************************************
//
// File autogenerated for the ${pkgname} package
// by the rosparam_handler package.
// Please do not edit.
//
// ********************************************************/

#pragma once

#include <stdlib.h>
#include <string>
#include <limits>
#include <ros/param.h>
#include <ros/node_handle.h>
#include <rosparam_handler/Parameters.h>
#ifdef DYNAMIC_RECONFIGURE_FOUND
#include <${pkgname}/${ClassName}Config.h>
#else
struct ${ClassName}Config{};
#endif

namespace ${pkgname} {

#ifndef UTIL_FUNCTIONS_${pkgname}
#define UTIL_FUNCTIONS_${pkgname}
template <typename T>
std::ostream& operator<< (std::ostream& out, const std::vector<T>& v) {
  if ( !v.empty() ) {
    out << '[';
    std::copy (v.begin(), v.end(), std::ostream_iterator<T>(out, ", "));
    out << "\b\b]";
  }
  return out;
}

template<typename T1, typename T2>
std::ostream &operator<<(std::ostream &stream, const std::map<T1, T2>& map)
{
  stream << '{';
  for (typename std::map<T1, T2>::const_iterator it = map.begin();
       it != map.end();
       ++it)
    {
      stream << (*it).first << " --> " << (*it).second << ", ";
    }
  stream << '}';
  return stream;
}

#endif /* UTIL_FUNCTIONS_${pkgname} */


struct ${ClassName}Parameters : public rosparam_handler::ParametersBase {
protected:

  using Base = rosparam_handler::ParametersBase;

public:

  using Config = ${ClassName}Config;

  ${ClassName}Parameters(const ros::NodeHandle& private_node_handle)
  : Base(private_node_handle) {}

  void fromParamServer() override{
$fromParamServer

$test_limits
  ROS_DEBUG_STREAM(*this);
  }

  void missingParamsWarning() override{
    ROS_WARN_STREAM("[" << nodeName << "]\nThe following parameters do not have default values and need to be specified:\n"
$non_default_params    );
  }

  $parameters

protected:

  virtual std::ostream& print(std::ostream& os) const override
  {
    os << "[" << nodeName << "]\nNode " << nodeName << " has the following parameters:\n"
$string_representation;

    return os;
  }
};

using ${ClassName}ParametersPtr = std::shared_ptr<${ClassName}Parameters>;

/// @todo Ensure safetyness ?
${ClassName}ParametersPtr castParametersPtr(rosparam_handler::ParametersPtr ptr)
{
  return std::dynamic_pointer_cast<${ClassName}Parameters>(ptr);
}

} // namespace ${pkgname}

namespace rosparam_handler {
namespace details {

  template <>
  void translate<>(rosparam_handler::ParametersBase* o, const ${pkgname}::${ClassName}Config& config, const uint32_t level)
  {
    ${pkgname}::${ClassName}Parameters* derived_ptr = static_cast<${pkgname}::${ClassName}Parameters*>(o);

#ifdef DYNAMIC_RECONFIGURE_FOUND
    $fromConfig
#else
  ROS_FATAL_STREAM("dynamic_reconfigure was not found during compilation. So fromConfig() is not available. Please recompile with dynamic_reconfigure.");
  std::exit(EXIT_FAILURE);
#endif
  }

} /* namespace details */
} /* namespace rosparam_handler */
