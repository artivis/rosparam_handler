# How to Use Your `rosparam_handler::ParameterPtr`
**Description**: This tutorial will familiarize you with how you can use the autogenerated parameter structs in your nodes from a base class smart-pointer. It is thus recommended to read the tutorial [How to use your parameters struct file](HowToUseYourParametersStruct.md) if you haven't yet.  
**Tutorial Level**: INTERMEDIATE

## Generated files
When creating params files as described in [How to write your first .params file](HowToWriteYourFirstParamsFile.md), you will end up with the following two files:
-   *'include/rosparam_tutorials/TutorialParameters.h'*
-   *'include/rosparam_tutorials/TutorialConfig.h'*

The '<name>Parameters.h' file will hold a struct called `<name>Parameters`.  
The '<name>Config.h' file will hold the normal dynamic_reconfigure Config struct.

For your code it is enough to include the \*Parameters.h file, e.g.

```cpp
#include "rosparam_tutorials/TutorialParameters.h"
```

You can now add an instance of the base parameter pointer to your class:

```cpp
rosparam_tutorials::ParametersPtr params_ptr_;
```

## Initializing the pointer.
When initializing your node, the params pointer `params_ptr_` must be instantiated to the appropriate parameter type with a private `NodeHandle`.

```cpp
MyNodeClass::MyNodeClass()
  : params_ptr_{boost::make_shared<TutorialParameters>(ros::NodeHandle("~"))}
{
  ...
}
```

In case your node has several classes, each using a different `ParameterPtr` object, the private `NodeHandle` must have a sub-namespace that is unique to your object in order to avoid parameters name collision.

```cpp
MyNodeClass::MyClass()
  : params_ptr_{boost::make_shared<TutorialParameters>(ros::NodeHandle("~/my_class"))}
{
  ...
}

MyNodeClass::MyOtherClass()
  : params_ptr_{boost::make_shared<TutorialParameters>(ros::NodeHandle("~/my_other_class"))}
{
  ...
}
```

## Initializing the struct.

The call to `fromParamServer()` is done the very same manner as for a normal parameter object.
It will take care of getting all parameter values from the parameter server, checking their type, and checking that a default value is set, if you haven't provided one on your own. If you have specified a default value, but the parameter is not yet present on the parameter server, it will be set. When min and max values are specified, these bounds will be checked as well.

```cpp
MyNodeClass::MyNodeClass()
  : params_ptr_{boost::make_shared<TutorialParameters>(ros::NodeHandle("~"))}
{
  params_ptr_->fromParamServer();
}
```

If you do not use a class (which you should do though in my opinion), you can create it like so:
```cpp
rosparam_tutorials::ParametersPtr params_ptr{boost::make_shared<TutorialParameters>(ros::NodeHandle("~"))}
params_ptr->fromParamServer();
```
Note: If you have set the logger level for your node to debug, you will get information on which values have been retrieved.  
Note: If you use nodelets, you have to use the `getPrivateNodeHandle()` function instead.

## Using dynamic_reconfigure
Your dynamic_reconfigure callback can now look as simple as:
```cpp
void reconfigureRequest(TutorialConfig& config, uint32_t level) {
    params_ptr_->fromConfig(config);
}
```
This will update all values that were specified as configurable. At the same time, it assures that all dynamic_reconfigure parameters live in the same namespace as those on the parameter server to avoid problems with redundant parameters.

You can find a running version of this example code in the [rosparam_handler_tutorial](https://github.com/cbandera/rosparam_handler_tutorial)-Repository

## Setting parameters on the server
If you change your parameters at runtime from within the code, you can upload the current state of the parameters with
```cpp
params_ptr_->toParamServer();
```
This will set all non-const parameters with their current value on the ros parameter server.
